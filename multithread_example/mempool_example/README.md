# C++ 线程池
## 基本概念
1. **线程池**: 当进行并行的任务作业操作时，线程的建立与销毁的开销是，阻碍性能进步的关键，因此线程池，由此产生。使用多个线程，无限制循环等待队列，进行计算和操作。帮助快速降低和减少性能损耗。
2. 主要组成部分：
   1. 任务队列(m_queue): 一个线程安全的队列。存储上层用户传入的任务。
   2. 线程池(ThreadPool)：从任务队列中分配任务给持有的线程。
    线程池和任务队列之间的匹配动作是典型的生产者-消费者模型。本实现中使用了一个mutex和一个条件变量；mutex用来保证任务添加和移除的互斥性。条件变量用来保证多个线程获取task的同步性。当任务队列为空的时候，线程应该阻塞等待
3. task和queue之间分配的方式：让每一个thread创建后，就去执行调度函数(位于ThreadWorker中)：循环获取task，然后执行。

## 任务队列
1. 目的是让任务根据到来的顺序执行，先到先执行。因此队列是合适的数据结构。
2. 线程池对任务队列的需求：多线程的持续查询任务队列是否有可用工作。因此需要实现一个线程安全的queue
3. 线程安全的queue的原理：使用mutex限制限制并发访问。
4. 对外暴露的接口:
   1. bool empty() 判断队列是否为空
   2. int size() 返回队列大小
   3. void enqueue(T &t) 添加元素到队列
   4. bool dequeue(T &t) 从队列取出元素

## 线程池
1. 线程池对外暴露的接口为：
   1. 构造函数：ThreadPool(const int n_threads)；用于确定该线程池中的线程数量
   2. void init()：用于线程池初始化，声明并分配工作线程，将工作线程放入工作线程队列m_threads中。
   3. submit函数：通过submit函数来提交任务
   4. shutdown：唤醒所有工作线程，并在等待完成所有工作后关闭线程池。
### submit函数
1. 用于向任务队列提交任务
2. submit函数的需求：
   1. 能够接受带有任何参数的任何函数(普通函数，Lambda，成员函数)
   2. 能够立即返回“东西”，避免阻塞主线程。





## 备注
1. unique_lock的使用方法之一是当离开局部的代码块的时候，局部对象被销毁的时候会自动解锁；当然也可以通过unlock解锁
2. future 某种意义上表示的是一个异步操作，通过其成员函数我们能够获悉异步操作处于什么样的情况。可以通过 get 来等待异步操作结束并返回结果，是一个阻塞过程。wait 等待异步操作结束，也是一个阻塞过程。wait_for 是超时等待返回结果，wait_util 类似。
3. function,bind可以参考[C++11中的lambda，std::function以及std:bind](https://paul.pub/cpp-lambda-function-bind/#id-stdfunction)
   1. 通过function可以应对
      1. 普通函数
      2. 成员函数
      3. lambda
      4. std::bind（见下文）后的结果
   2. bind可以参数绑定到函数上(当作参数)
4. 
5. 参考了https://zhuanlan.zhihu.com/p/367309864
